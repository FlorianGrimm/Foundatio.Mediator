using System.Diagnostics;
using Foundatio.Mediator.Models;
using Foundatio.Mediator.Utility;

namespace Foundatio.Mediator;

[Generator]
public sealed class MediatorGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var generatorConfiguration = context.CompilationProvider
            .Select(static (compilation, _) => GetConfiguration(compilation))
            .WithTrackingName(TrackingNames.Settings);

        var callSites = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (s, _) => CallSiteAnalyzer.IsMatch(s),
                transform: static (ctx, _) => CallSiteAnalyzer.GetCallSite(ctx))
            .Where(static cs => cs.HasValue)
            .Select(static (cs, _) => cs!.Value)
            .WithTrackingName(TrackingNames.CallSites);

        var middleware = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (s, _) => MiddlewareAnalyzer.IsMatch(s),
                transform: static (ctx, _) => MiddlewareAnalyzer.GetMiddleware(ctx))
            .Where(static m => m.HasValue)
            .Select(static (middleware, _) => middleware!.Value)
            .WithTrackingName(TrackingNames.Middleware);

        var handlers = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (s, _) => HandlerAnalyzer.IsMatch(s),
                transform: static (ctx, _) => HandlerAnalyzer.GetHandlers(ctx))
            .Where(static m => m is not null && m.Count > 0)
            .SelectMany(static (handlers, _) => handlers ?? [])
            .WithTrackingName(TrackingNames.Handlers);

        var compilationAndData = handlers.Collect()
            .Combine(middleware.Collect())
            .Combine(callSites.Collect())
            .Combine(generatorConfiguration)
            .Combine(context.CompilationProvider)
            .Select(static (spc, _) => (
                Handlers: spc.Left.Left.Left.Left,
                Middleware: spc.Left.Left.Left.Right,
                CallSites: spc.Left.Left.Right,
                Configuration: spc.Left.Right,
                Compilation: spc.Right
            ));

        context.RegisterImplementationSourceOutput(compilationAndData,
            static (spc, source) => Execute(source.Handlers, source.Middleware, source.CallSites, source.Configuration, source.Compilation, spc));
    }

    /// <summary>
    /// Reads [assembly: MediatorConfiguration] and returns parsed generator configuration.
    /// </summary>
    private static GeneratorConfiguration GetConfiguration(Compilation compilation)
    {
        var isCSharpSufficient = compilation is CSharpCompilation { LanguageVersion: LanguageVersion.Default or >= LanguageVersion.CSharp11 };

        var configAttr = compilation.Assembly.GetAttributes()
            .FirstOrDefault(a => a.AttributeClass?.ToDisplayString() == WellKnownTypes.MediatorConfigurationAttribute);

        // Defaults
        bool disableInterceptors = false;
        string handlerLifetime = "None";
        string middlewareLifetime = "None";
        bool disableOpenTelemetry = false;
        bool conventionalDiscoveryDisabled = false;
        bool generationCounterEnabled = false;
        string notificationPublisher = "ForeachAwait";
        string? projectName = null;

        if (configAttr != null)
        {
            foreach (var arg in configAttr.NamedArguments)
            {
                switch (arg.Key)
                {
                    case "DisableInterceptors" when arg.Value.Value is bool b:
                        disableInterceptors = b;
                        break;
                    case "HandlerLifetime" when arg.Value.Value is int v:
                        handlerLifetime = v switch { 1 => "Transient", 2 => "Scoped", 3 => "Singleton", _ => "None" };
                        break;
                    case "MiddlewareLifetime" when arg.Value.Value is int v:
                        middlewareLifetime = v switch { 1 => "Transient", 2 => "Scoped", 3 => "Singleton", _ => "None" };
                        break;
                    case "DisableOpenTelemetry" when arg.Value.Value is bool b:
                        disableOpenTelemetry = b;
                        break;
                    case "HandlerDiscovery" when arg.Value.Value is int v:
                        conventionalDiscoveryDisabled = v == 1; // Explicit = 1
                        break;
                    case "NotificationPublisher" when arg.Value.Value is int v:
                        notificationPublisher = v switch { 1 => "TaskWhenAll", 2 => "FireAndForget", _ => "ForeachAwait" };
                        break;
                    case "ProjectName" when arg.Value.Value is string s:
                        projectName = s;
                        break;
                    case "EnableGenerationCounter" when arg.Value.Value is bool b:
                        generationCounterEnabled = b;
                        break;
                }
            }
        }

        var interceptorsEnabled = !disableInterceptors && isCSharpSufficient;
        var openTelemetryEnabled = !disableOpenTelemetry;

        return new GeneratorConfiguration(interceptorsEnabled, handlerLifetime, middlewareLifetime,
            openTelemetryEnabled, conventionalDiscoveryDisabled, generationCounterEnabled, notificationPublisher, projectName);
    }

    /// <summary>
    /// Reads endpoint defaults from [assembly: MediatorConfiguration].
    /// </summary>
    private static EndpointDefaultsInfo GetEndpointDefaults(Compilation compilation)
    {
        var configAttr = compilation.Assembly.GetAttributes()
            .FirstOrDefault(a => a.AttributeClass?.ToDisplayString() == WellKnownTypes.MediatorConfigurationAttribute);

        if (configAttr == null)
            return EndpointDefaultsInfo.Default;

        string discovery = "None";
        string? routePrefix = "/api";
        var filters = Array.Empty<string>();
        bool requireAuth = false;
        string? policy = null;
        var roles = Array.Empty<string>();
        string summaryStyle = "Exact";

        foreach (var arg in configAttr.NamedArguments)
        {
            switch (arg.Key)
            {
                case "EndpointDiscovery" when arg.Value.Value is int v:
                    discovery = v switch { 1 => "Explicit", 2 => "All", _ => "None" };
                    break;
                case "EndpointRoutePrefix" when arg.Value.Value is string s:
                    routePrefix = s;
                    break;
                case "EndpointFilters" when !arg.Value.IsNull && arg.Value.Kind == TypedConstantKind.Array:
                    filters = arg.Value.Values
                        .Where(v => v.Value is INamedTypeSymbol)
                        .Select(v => ((INamedTypeSymbol)v.Value!).ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat))
                        .ToArray();
                    break;
                case "EndpointRequireAuth" when arg.Value.Value is bool b:
                    requireAuth = b;
                    break;
                case "EndpointPolicy" when arg.Value.Value is string s:
                    policy = s;
                    break;
                case "EndpointRoles" when !arg.Value.IsNull && arg.Value.Kind == TypedConstantKind.Array:
                    roles = arg.Value.Values
                        .Where(v => v.Value is string)
                        .Select(v => (string)v.Value!)
                        .ToArray();
                    break;
                case "EndpointSummaryStyle" when arg.Value.Value is int v:
                    summaryStyle = v switch { 1 => "Spaced", _ => "Exact" };
                    break;
            }
        }

        return new EndpointDefaultsInfo
        {
            Discovery = discovery,
            RoutePrefix = routePrefix,
            Filters = new(filters),
            RequireAuth = requireAuth,
            Policy = policy,
            Roles = new(roles),
            SummaryStyle = summaryStyle,
            IsConfigured = true
        };
    }

    private static void Execute(ImmutableArray<HandlerInfo> handlers, ImmutableArray<MiddlewareInfo> middleware, ImmutableArray<CallSiteInfo> callSites, GeneratorConfiguration configuration, Compilation compilation, SourceProductionContext context)
    {
        var sw = Stopwatch.StartNew();

        // Filter out conventionally-discovered handlers when conventional discovery is disabled
        var filteredHandlers = configuration.ConventionalDiscoveryDisabled
            ? handlers.Where(h => h.IsExplicitlyDeclared).ToImmutableArray()
            : handlers;

        // Filter out conventionally-discovered middleware when conventional discovery is disabled
        var filteredMiddleware = configuration.ConventionalDiscoveryDisabled
            ? middleware.Where(m => m.IsExplicitlyDeclared).ToImmutableArray()
            : middleware;

        // Scan referenced assemblies for cross-assembly middleware
        var metadataMiddleware = MetadataMiddlewareScanner.ScanReferencedAssemblies(compilation);

        // Combine syntax-based middleware (from current assembly) with metadata-based middleware (from referenced assemblies)
        var allMiddleware = filteredMiddleware.ToList();
        allMiddleware.AddRange(metadataMiddleware);

        // Scan referenced assemblies for cross-assembly handlers
        var crossAssemblyHandlers = CrossAssemblyHandlerScanner.ScanReferencedAssemblies(compilation);

        var callSitesByMessage = callSites.ToList()
            .Where(cs => !cs.IsPublish)
            .GroupBy(cs => cs.MessageType)
            .ToDictionary(g => g.Key, g => g.ToArray());

        // Track which call sites are handled by cross-assembly handlers
        var crossAssemblyCallSites = new List<CallSiteInfo>();
        var crossAssemblyHandlerMessageTypes = new HashSet<string>(crossAssemblyHandlers.Select(h => h.MessageType.FullName));

        var handlersWithInfo = new List<HandlerInfo>();
        foreach (var handler in filteredHandlers)
        {
            callSitesByMessage.TryGetValue(handler.MessageType, out var handlerCallSites);
            var applicableMiddleware = GetApplicableMiddlewares(allMiddleware.ToImmutableArray(), handler, compilation, configuration, out var orderingDiagnostics);

            // Resolve effective handler lifetime: use explicit lifetime if set, otherwise use project default
            var resolvedHandlerLifetime = ResolveEffectiveLifetime(handler.Lifetime, configuration.DefaultHandlerLifetime);

            handlersWithInfo.Add(handler with { CallSites = new(handlerCallSites), Middleware = applicableMiddleware, Lifetime = resolvedHandlerLifetime, OrderingDiagnostics = new(orderingDiagnostics.ToArray()) });
        }

        // Collect call sites that need cross-assembly interceptors
        foreach (var callSite in callSites)
        {
            if (callSite.IsPublish)
                continue;

            // Check if this message type has a handler in a referenced assembly but NOT in the current assembly
            bool hasLocalHandler = filteredHandlers.Any(h => h.MessageType.FullName == callSite.MessageType.FullName);
            bool hasCrossAssemblyHandler = crossAssemblyHandlerMessageTypes.Contains(callSite.MessageType.FullName);

            if (!hasLocalHandler && hasCrossAssemblyHandler)
            {
                crossAssemblyCallSites.Add(callSite);
            }
        }

        // Always generate diagnostics related to call sites, including cross-assembly handler validation
        HandlerGenerator.ValidateGlobalCallSites(context, handlersWithInfo, callSites, crossAssemblyHandlers);

        // Generate assembly attribute and handlers registration if there are handlers or middleware (enables cross-assembly discovery)
        if (handlersWithInfo.Count > 0 || middleware.Length > 0)
        {
            FoundatioModuleGenerator.Execute(context, compilation, handlersWithInfo, filteredMiddleware, configuration);
        }

        // Generate the InterceptsLocation attribute if we need interceptors (for local, cross-assembly, or publish handlers)
        bool hasPublishInterceptors = configuration.InterceptorsEnabled && callSites.Any(cs => cs.IsPublish && !cs.MessageType.IsTypeParameter);
        bool needsInterceptors = handlersWithInfo.Count > 0 || crossAssemblyCallSites.Count > 0 || hasPublishInterceptors;
        if (needsInterceptors)
        {
            InterceptsLocationGenerator.Execute(context, configuration);
        }

        // Generate cross-assembly interceptors if there are call sites to handlers in referenced assemblies
        if (crossAssemblyCallSites.Count > 0)
        {
            CrossAssemblyInterceptorGenerator.Execute(context, crossAssemblyHandlers, crossAssemblyCallSites.ToImmutableArray(), configuration);
        }

        // Combine local and cross-assembly handlers for cascading message handler lookup
        var allHandlers = handlersWithInfo.Concat(crossAssemblyHandlers).ToList();

        // Generate publish interceptors when interceptors are enabled
        if (configuration.InterceptorsEnabled)
        {
            var publishCallSites = callSites.Where(cs => cs.IsPublish && !cs.MessageType.IsTypeParameter).ToList();
            if (publishCallSites.Count > 0)
            {
                PublishInterceptorGenerator.Execute(context, publishCallSites, allHandlers, configuration);
            }
        }

        // Generate endpoint registration for all handlers (local + cross-assembly)
        // This must happen before the early return so WebApp can generate endpoints for handlers in referenced modules
        var endpointDefaults = GetEndpointDefaults(compilation);
        EndpointGenerator.Execute(context, allHandlers, endpointDefaults, configuration, compilation);

        if (handlersWithInfo.Count == 0)
        {
            sw.Stop();
            GeneratorDiagnostics.LogExecute(
                compilation.AssemblyName ?? "Unknown",
                handlersWithInfo.Count,
                allMiddleware.Count,
                callSites.Length,
                crossAssemblyHandlers.Count,
                sw.ElapsedMilliseconds);
            return;
        }

        // Generate shared async helpers once per assembly (used by all handlers)
        HelpersGenerator.Execute(context, configuration);

        HandlerGenerator.Execute(context, handlersWithInfo, allHandlers, configuration);

        sw.Stop();
        GeneratorDiagnostics.LogExecute(
            compilation.AssemblyName ?? "Unknown",
            handlersWithInfo.Count,
            allMiddleware.Count,
            callSites.Length,
            crossAssemblyHandlers.Count,
            sw.ElapsedMilliseconds);
    }

    private static EquatableArray<MiddlewareInfo> GetApplicableMiddlewares(ImmutableArray<MiddlewareInfo> middlewares, HandlerInfo handler, Compilation compilation, GeneratorConfiguration configuration, out List<DiagnosticInfo> orderingDiagnostics)
    {
        orderingDiagnostics = [];
        var applicable = new List<MiddlewareInfo>();
        var addedMiddlewareTypes = new HashSet<string>();

        // Add middleware that matches by message type (global middleware)
        // Skip middleware marked as ExplicitOnly - those are only added via [UseMiddleware] references
        foreach (var middleware in middlewares)
        {
            if (middleware.ExplicitOnly)
                continue;

            if (IsMiddlewareApplicableToHandler(middleware, handler))
            {
                // Resolve effective middleware lifetime
                var resolvedLifetime = ResolveEffectiveLifetime(middleware.Lifetime, configuration.DefaultMiddlewareLifetime);
                applicable.Add(middleware with { Lifetime = resolvedLifetime });
                addedMiddlewareTypes.Add(middleware.FullName);
            }
        }

        // Add handler-specific middleware from [UseMiddleware] and custom attributes
        foreach (var reference in handler.HandlerMiddlewareReferences)
        {
            // Find the middleware info from the global list
            var middlewareInfo = middlewares.FirstOrDefault(m => m.FullName == reference.MiddlewareTypeName);
            if (middlewareInfo.FullName == null)
                continue; // Middleware not found - could emit diagnostic here

            // Resolve effective middleware lifetime
            var resolvedLifetime = ResolveEffectiveLifetime(middlewareInfo.Lifetime, configuration.DefaultMiddlewareLifetime);

            if (addedMiddlewareTypes.Contains(middlewareInfo.FullName))
            {
                // Middleware already added from message type matching
                // Update the order if the handler attribute specifies one
                if (reference.Order != int.MaxValue)
                {
                    var index = applicable.FindIndex(m => m.FullName == middlewareInfo.FullName);
                    if (index >= 0)
                    {
                        applicable[index] = applicable[index] with { Order = reference.Order, Lifetime = resolvedLifetime };
                    }
                }
            }
            else
            {
                // Add middleware with handler-specified order and resolved lifetime
                applicable.Add(middlewareInfo with { Order = reference.Order, Lifetime = resolvedLifetime });
                addedMiddlewareTypes.Add(middlewareInfo.FullName);
            }
        }

        // Use topological sort to respect OrderBefore/OrderAfter constraints with numeric Order as tiebreaker
        List<DiagnosticInfo> cycleDiagnostics;
        var sorted = MiddlewareOrderingSorter.Sort(
            applicable,
            m => m.FullName,
            m => (IEnumerable<string>)m.OrderBefore,
            m => (IEnumerable<string>)m.OrderAfter,
            m => m.Order ?? int.MaxValue,
            out cycleDiagnostics);

        // If there were no relative ordering constraints, apply the original secondary sort (message type specificity)
        // For items at the same numeric order level, prefer specific types over interfaces over object
        if (!applicable.Any(m => m.OrderBefore.Any() || m.OrderAfter.Any()))
        {
            sorted = sorted
                .OrderBy(m => m.Order ?? int.MaxValue)
                .ThenBy(m => m.MessageType.IsObject ? 2 : (m.MessageType.IsInterface ? 1 : 0))
                .ToList();
        }

        // Propagate cycle diagnostics to the caller for reporting
        if (cycleDiagnostics.Count > 0)
        {
            orderingDiagnostics.AddRange(cycleDiagnostics);
        }

        return new EquatableArray<MiddlewareInfo>(sorted.ToArray());
    }

    private static bool IsMiddlewareApplicableToHandler(MiddlewareInfo middleware, HandlerInfo handler)
    {
        if (middleware.MessageType.IsObject)
            return true;

        if (middleware.MessageType.FullName == handler.MessageType.FullName)
            return true;

        // Check if middleware message type is an interface implemented by the handler message type
        if (middleware.MessageType.IsInterface && handler.MessageInterfaces.Contains(middleware.MessageType.FullName))
            return true;

        // Check if middleware message type is a base class of the handler message type
        if (handler.MessageBaseClasses.Contains(middleware.MessageType.FullName))
            return true;

        return false;
    }

    /// <summary>
    /// Resolves the effective lifetime by using the explicit lifetime if set, otherwise the default.
    /// Returns null if both are "None" (meaning no DI registration needed - use lazy caching).
    /// </summary>
    private static string? ResolveEffectiveLifetime(string? explicitLifetime, string defaultLifetime)
    {
        // If explicit lifetime is set and not "None", use it
        if (!string.IsNullOrEmpty(explicitLifetime) &&
            !string.Equals(explicitLifetime, "None", StringComparison.OrdinalIgnoreCase))
        {
            return explicitLifetime;
        }

        // Fall back to default lifetime if it's not "None"
        if (!string.Equals(defaultLifetime, "None", StringComparison.OrdinalIgnoreCase))
        {
            return defaultLifetime;
        }

        // Both are "None" - return null to indicate no DI registration
        return null;
    }
}

